


class Solution {
public:
    bool possible(vector<int>& arr, int day, int m, int k) {
        int cnt = 0, bouquets = 0;

        for(int i = 0; i < arr.size(); i++) {
            if(arr[i] <= day) {
                cnt++;
                if(cnt == k) {
                    bouquets++;
                    cnt = 0;
                }
            } else {
                cnt = 0;
            }
        }
        return bouquets >= m;
    }

    int minDays(vector<int>& bloomDay, int m, int k) {
        long long total = 1LL * m * k;
        if(total > bloomDay.size()) return -1;

        int low = *min_element(bloomDay.begin(), bloomDay.end());
        int high = *max_element(bloomDay.begin(), bloomDay.end());
        int ans = -1;

        while(low <= high) {
            int mid = low + (high - low) / 2;

            if(possible(bloomDay, mid, m, k)) {
                ans = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return ans;
    }
};








<<<<<<<<<<<<<<............>>>>>>>>>>>>>>>>
Search a 2D Matrix

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int n=matrix.size();
        int m=matrix[0].size(),ans=0;
        int low=0,high=m*n-1;
        while(low<=high)
        {
            int mid=low+(high-low)/2;
            int row=mid/m;
            int col=mid%m;
            if(matrix[row][col]==target) return true;
            else if(matrix[row][col]<target) low=mid+1;
            else high=mid-1;
        }
        return false;
    }
};







<<<<<<<<<<<<<<<<............>>>>>>>>>>>>>>>
Find nth root of m

class Solution {
  public:
    int nthRoot(int n, int m) {
        // Code here
        long long low=0,high=m,ans=-1;
        while(low<=high)
        {
            long long mid=low+(high-low)/2;
            long long sum=1;
            for(int i=0;i<n;i++)
            {
                sum*=mid;
                if(sum>m) break;
            }
            if(sum==m) return mid;
            else if(sum<m) low=mid+1;
            else high=mid-1;
        }
        return ans;
    }
};






<<<<<<<<<<<<<<<<<<<..................>>>>>>>>>>>>>>>>>>>>
Find the Smallest Divisor Given a Threshold

class Solution {
public:
    int smallestDivisor(vector<int>& nums, int threshold) {
        int low=1,high=*max_element(nums.begin(), nums.end()),ans=0;
        while(low<=high)
        {
            int mid = low + (high - low)/2;
            long long count=0;
            for(int i=0;i<nums.size();i++)
            {
                if(nums[i]%mid==0)
                {
                    count+=nums[i]/mid;
                }else
                {
                    count+=nums[i]/mid +1;
                }
            }
            if(count <= threshold) high=mid-1;
            else  low=mid+1;
            ans=low;
        }
        return ans;
    }
};








<<<<<<<<<<<<<<<.....>>>>>>>>>>>>>>>>
Kth Missing Positive Number

class Solution {
public:
    int findKthPositive(vector<int>& arr, int k) {
        int low=0,high=arr.size()-1;
        while(low<=high)
        {
            int mid=low+(high-low)/2;
            int miss=arr[mid]-(mid+1);
            if(miss<k) low=mid+1;
            else high=mid-1;
        }
        return k+high+1;
    }
};








<<<<<<<<<<<<<<<<<...............>>>>>>>>>>>>>>>>>>
Koko Eating Bananas

class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        
        int low=1,high = *max_element(piles.begin(), piles.end()),ans=0;
        while(low<=high)
        {
            int mid=low+(high-low)/2;
            long long sum=0;
            for(int i=0;i<piles.size();i++)
            {
                if(piles[i]%mid==0)
                {
                    sum+=piles[i]/mid;
                }else{
                    sum+=piles[i]/mid +1;
                }
            }
            if(sum<=h) high=mid-1;
            else low=mid+1;
            ans=low ;
        }
        return ans;
    }
};







<<<<<<<<<<<<<<<............>>>>>>>>>>>>>>>
Ceil in a Sorted Array

// User function Template for C++
class Solution {
  public:
    int findCeil(vector<int>& arr, int x) {
        // code here
        int low=0,high=arr.size()-1;
        int t=high+1;
        while(low<=high)
        {
            int mid=low+(high-low)/2;
            
            if(arr[mid]>=x)
            {
                high=mid-1;
            }
            else
            low=mid+1;
        }
        if(low==t) return -1;
        return low;
    }
};






<<<<<<<<<<<<<<<<<<<<<<<<<................>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Find First and Last Position of Element in Sorted Array

class Solution {
public:
 int fristp(vector<int>& nums, int target)
 {
    int low = 0, high = nums.size() - 1, ans = -1;
    while(low<=high)
    {
        int mid=low+(high-low)/2;
        if(nums[mid]==target)
        {
            ans=mid;
            high=mid-1;
        }
        else if(nums[mid]<target) low=mid+1;
        else high=high-1;
    }
    return ans;
 }

  int lastp(vector<int>& nums, int target)
 {
    int low = 0,high = nums.size() - 1,ans = -1;
    while(low<=high)
    {
        int mid=low+(high-low)/2;
        if(nums[mid]==target)
        {
            ans=mid;
            low=mid+1;
        }
        else if(nums[mid]<target) low=mid+1;
        else high=high-1;
    }
    return ans;
 }
    vector<int> searchRange(vector<int>& nums, int target) {
     
        return {fristp(nums,target),lastp(nums,target)};
    }
};







<<<<<<<<<<<<<<<...........>>>>>>>>>>>>>>>
Search Insert Position

class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n=nums.size()-1;
        int low=0, high=n;
        while(low<=high)
        {
            int mid = low + (high-low)/2;
            if(nums[mid]==target) return mid;
            else if(nums[mid]<target) 
            {
                low=mid+1;
            }
            else 
            {
                high=mid-1;
            }
        }
        return low;
        
    }
};








<<<<<<<<<<<<<<<<<<<<<<................>>>>>>>>>>>>>>>>>>>>>>>>>>
Find Minimum in Rotated Sorted Array

class Solution {
public:
    int findMin(vector<int>& nums) {
        int low=0,high=nums.size()-1;
        while(low<high)
        {
            int mid=low+(high-low)/2;
            if(nums[mid]>nums[high])
            {
               low=mid+1;
            }
            else
            {
                high=mid;
            }
        }
        return nums[low];
    }
};








<<<<<<<<<<<<<<<<<<<..............>>>>>>>>>>>>>>>>>>>
Single Element in a Sorted Array

class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int low=0,high=nums.size()-1;
        while(low<high)
        {
            int mid=low+(high-low)/2;
            
            if(mid%2==1)
            mid--;

            if(nums[mid]==nums[mid+1])
            {
                low=mid+2;
            }
            else
            {
                high=mid;
            }
        } 
        return nums[low];    }
};










<<<<<<<<<<<<<<<<<<<<....................>>>>>>>>>>>>>>>>>>>>>
Sqrt(x)

class Solution {
public:
    int mySqrt(int x) {
        long long low=0,high=x,ans=0;
        if(x==0 || x==1)
        {
            return x;
        }
        while(low<=high)
        {
            long long mid=low+(high-low)/2;
            if(mid*mid==x)
            {
                return mid;
            }
            if(mid*mid<x)
            {
                ans=mid;
                low=mid+1;
               
            }
            else{
                 high=mid-1;
            }
        }
        return ans;
    }
};











<<<<<<<<<<<<<<<<<<<<<<<......................>>>>>>>>>>>>>>>>>>>>>
Binary-Search

class Solution {
public:
    int search(vector<int>& nums, int target) {
        int low=0; int high=nums.size()-1;
        while(low<=high)
        {
            int mid=(low+high)/2;
            if(nums[mid]==target)
            {
                return mid;
            }
            else if(nums[mid]<target)
            {
               low=mid+1;
            }
            else if(nums[mid]>target)
            {
                high=mid-1;
            }
        }
        return -1;
    }
};











<<<<<<<<<<<<<<<<<<<<<<<......................>>>>>>>>>>>>>>>>>>>>>
Find Smallest Letter Greater Than Target
class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) {
        int low=0;int high =letters.size()-1;
        int ans=letters[0];
        while(low<=high)
        {
            int mid=(low+high)/2;
            if(target<letters[mid])
            {
                high=mid-1;
                ans=letters[mid];
            }
            else
            {
                low=mid+1;
            }
        }
        return ans;
    }
};






<<<<<<<<<<<<<<<<<<<<<<<......................>>>>>>>>>>>>>>>>>>>>>
Find Peak Element

class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int n=nums.size();
        int low=0;
        int high=n-1;
        while(low<high)
        {
            int mid=(low+high)/2;
            if(nums[mid]<nums[mid+1])
            {
                low=mid+1;
            }
            else
            {
                high=mid;
            }
        }
        return low;
    }
};
